---
title: Golang -- 拾遗 Part1 
---

> Golang语言小白学习基础知识

* “_”空标识符。忽略后续没有引用，可以用于未使用变量，希望加载module中的初始化函数，或者定义一个”子类“ nil变量，约束子类实现了接口所有方法，否则编译阶段就能出错。

* Const的在空时，自动使用上一个值:

  ```go
  const （
  a = “abc”
  b
  ）
  ```

* Const使用iota实现枚举，每个iota自增：

   ```go
  const （
  x = iota *10   // 0
  y	             // 10
  z              // 20
  ）
   ```

* rune 是int32别名，byte是uint8别名，可以直接赋值。

* slice，map，channel是引用类型，要用make初始化，new不会初始化完成。

*  除了常量，别名，未命名类型，都需要显式转换。

* struct tag也是类型组成部分， 换句话说，tag不同类型不同。
* 复合类初始化，每行以逗号或花括号结尾。
* 局部变量 在整个if else块可用。
* switch默认自带break，所有case不成立时进入default，如果想进入下一case，需要显式使用fallthrough，fallthrough不能用于最后的case。
* goto/continue/break可以配合标签使用，但标签必须是函数内代码段，虽然会说经历不要用goto，有pattern可以处理，但是有些场景下，goto也不错。
* 函数返回局部变量指针是安全的。通过逃逸分析，自动在堆上分配内存。
* 传指针还是复制对象？复制指针可能会延长目标对象的生命周期，还可能回导致分配到堆上，性能损耗要加上内存分配和垃圾回收。
* 函数参数过多应该重构成struct，如Option。
*  函数变参本质上是slice，仅能放在参数最后，函数参数复制时仅是slice本身，不包括底层数组。
* 函数支持多返回值，但是不支持元组类型的返回，可作为其他函数调用实参。
* 命名返回值可以当作函数局部变量，如果类型能表明含义，尽量不要命名。
* 匿名函数可以在函数内部定义，实现类似嵌套效果，也可以赋值给变量或者放在chan中，如果匿名函数定义，但未被调用，编译阶段会报错。
* 闭包本质上是函数和引用环境的组合，使用时注意“延迟求值”的特性。
* 闭包提供了不传参数就可以读取/修改环境的办法，但是在并发情况下就需要做同步处理，会有额外代价。
* defer时，对参数的注意闭包引用和参数传递的区别，return 100，执行顺序是 ret=100， call defer，实际return。
* 循环和处理算法应该分离。
* defer会带来性能损失，如测试mutex lock/unlock，使用defer与不使用，性能相差2-4倍。
* 错误处理通常以err为前缀，字符串内容全部小写，没有结束标点，以便嵌入其他格式化字符，自定义错误类型时，需要实现Error（）string的接口方法。
* 大量处理error返回值的思路有：
  * 使用专门的检查函数处理（如日志）
  * defer延迟处理error
  * 将error作为内部状态保存，最终处理。
* panic/recover是golang的错误处理内置函数，并非语句。recover仅在defer函数中正常工作，在defer中执行panic并不会中断后续defer的执行。 runtime.PrintStack可以输出完整调用栈信息。